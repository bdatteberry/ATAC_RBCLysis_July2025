#!/usr/bin/env Rscript
# =============================================================================
#                             ATAC-Seq Pipeline Starter
#                 (uses dynamic date/paths from 00_auto_paths.R)
# =============================================================================

# ---- Load Libraries ---------------------------------------------------------
suppressPackageStartupMessages({
  library(tidyverse)
  library(DESeq2)
  library(eulerr)
  library(GenomicRanges)
  library(VennDiagram)
  library(pheatmap)
  library(akima)
  library(ggrepel)
  library(UpSetR)
  library(RColorBrewer)
  library(stringr)
  library(viridis)
  library(purrr)
  library(reshape2)
  library(umap)
})

# variancePartition is optional and not required for the code below:
if (requireNamespace("variancePartition", quietly = TRUE)) {
  suppressPackageStartupMessages(library(variancePartition))
} else {
  message("ℹ️ Skipping 'variancePartition' (not installed).")
}

# ---- Bootstrap paths & today's date (LA time) -------------------------------
# Expect that you've already run Directory_creation.r once today.
# It writes scripts/00_auto_paths.R which recomputes the date at source-time.

# Project root (fallback if option not set)
main_wd <- getOption("project.main_wd",
                     "/Users/brandiatteberry/Desktop/Bioinformatics/ATACseq_Analysis")
# remove trailing slashes
main_wd <- sub("/+$", "", main_wd)

# Find scripts folder, prefer the global option set by Directory_creation.r
scripts_wd <- getOption("project.scripts_wd", file.path(main_wd, "scripts"))
auto_paths <- file.path(scripts_wd, "00_auto_paths.R")
if (!file.exists(auto_paths)) {
  stop("Missing ", auto_paths,
       "\nRun Directory_creation.r first to create today's folders and 00_auto_paths.R.")
}
source(auto_paths)  # defines current_date, output_wd, homer_wd, file_a, file_b, etc.
options(project.scripts_wd = scripts_wd)

# Helper to ensure dirs exist (idempotent)
create_dir <- function(dir_path) {
  if (!dir.exists(dir_path)) dir.create(dir_path, recursive = TRUE)
  invisible(dir_path)
}

# Make sure all expected output dirs for *today* exist
invisible(lapply(list(
  main_wd, macs_wd, scale_wd, deseq_wd, output_wd, homer_wd,
  seq_stats_wd, rep_overlap_wd, pre_deseq_reps_wd, homer_r_wd,
  merged_norm_wd, deseq_dds_folder, deseq_dds_folder_reps_overlap,
  scripts_wd, snapshots_wd
), create_dir))

message("✅ Using date tag: ", current_date)
message("✅ Outputs -> ", output_wd)

# ---- Reference files (auto-find under project; fallback to training) --------
training_dir <- "/Users/brandiatteberry/Desktop/Bioinformatics/RBC_Lysis_Bioinformatics_training"

.find_under <- function(root, pattern) {
  list.files(root, pattern = pattern, recursive = TRUE, full.names = TRUE, ignore.case = TRUE)
}
.first_existing <- function(...) {
  cands <- unlist(list(...), use.names = FALSE)
  ex <- cands[file.exists(cands)]
  if (length(ex) > 0) ex[1] else character(0)  # return length-0 if none, not NA
}

# Prefer files from your project; use training_dir only if not found
counts_file <- .first_existing(
  .find_under(main_wd, "featureCounts.*\\.txt$"),
  file.path(training_dir, "consensus_peaks.mRp.clN.featureCounts_1.txt")
)

homer_annot <- .first_existing(
  .find_under(main_wd, "consensus_peaks.*annotate.*(HOMER|annotated).*\\.txt$"),
  file.path(training_dir, "consensus_peaks_annotated_HOMER.txt")
)

# Prefer merged colData you created in output_wd; fall back to training
coldata_file <- .first_existing(
  file.path(output_wd, "deseq_input_merged_samples_PARSED.csv"),
  file.path(output_wd, "deseq_input_merged_samples.csv"),
  file.path(output_wd, "coldata_for_DESeq2.csv"),
  file.path(training_dir, "deseq_input_merged_samples.csv"),
  file.path(training_dir, "coldata_for_DESeq2.csv")
)

peak_bed_file <- .first_existing(
  .find_under(main_wd, "\\.mLb\\.clN\\.bed$"),
  file.path(training_dir, "consensus_peaks.mLb.clN.bed")
)

boolean_file <- .first_existing(
  .find_under(main_wd, "\\.boolean\\.txt$"),
  file.path(training_dir, "consensus_peaks.mRp.clN.boolean.txt")
)

# Split featureCounts files (also defined in 00_auto_paths.R as file_a / file_b)
file_first_six   <- file_a
file_bam_columns <- file_b

# Sanity check key refs (warn, don't hard-stop so you can run pieces)
ref_paths <- c(
  counts_file  = counts_file,
  homer_annot  = homer_annot,
  coldata_file = coldata_file,
  peak_bed_file= peak_bed_file,
  boolean_file = boolean_file
)
is_missing <- function(p) length(p) == 0 || !file.exists(p)
miss_keys  <- names(ref_paths)[vapply(ref_paths, is_missing, logical(1))]
if (length(miss_keys)) {
  lines <- vapply(miss_keys, function(k) {
    p <- ref_paths[[k]]
    sprintf(" - %-13s %s", paste0(k, ":"), if (length(p)) p else "<not found>")
  }, character(1))
  warning("Missing reference file(s):\n", paste(lines, collapse = "\n"))
}

# ---- Plot Theme -------------------------------------------------------------
my_ggplot_theme <- theme_classic() +
  theme(
    text         = element_text(color = "black"),
    plot.title   = element_text(hjust = 0.5, size = rel(1.5)),
    axis.text.x  = element_text(size = rel(1.25)),
    axis.text.y  = element_text(size = rel(1.25), angle = 90, hjust = 0.5),
    axis.title.y = element_text(size = rel(1.25))
  )

# =============================================================================
#                             Utility Functions
# =============================================================================
w <- function(a) { print(head(a)); print(nrow(a)) }

# =============================================================================
#                             Functions from Script 01
# =============================================================================

# Boolean filtering helper (keeps only .bool, strips .mRp.clN.bool)
boolean_filtering_function <- function(input_df, samples) {
  bool_data <- input_df %>% select(ends_with(".bool"))
  if (ncol(bool_data) == 0) stop("No *.bool columns found. Make sure boolean/split steps ran.")
  colnames(bool_data) <- colnames(bool_data) %>% str_replace("\\.mRp\\.clN\\.bool$", "")
  bool_data %>% select(any_of(samples))
}

# UpSetR plot for “untreated”-style groups (with empty-guard)
untreated_upsetR_plot <- function(input_data, plot_name) {
  input_df_samples <- input_data[, 5:ncol(input_data), drop = FALSE]
  colnames(input_df_samples) <- str_replace(colnames(input_df_samples), "^X", "")
  if (ncol(input_df_samples) < 2 || sum(colSums(input_df_samples) > 0) == 0) {
    message("Skipping UpSetR (not enough non-empty sets) for ", plot_name)
    return(invisible(NULL))
  }
  png_filename <- file.path(output_wd, paste0("upsetR_plot_", plot_name, "_", current_date, ".png"))
  png(png_filename, width = 1800, height = 1000, res = 120)
  print(
    upset(
      data           = input_df_samples,
      sets           = names(input_df_samples),
      order.by       = "freq",
      main.bar.color = "grey",
      matrix.color   = "#7E2945",
      text.scale     = 1.25,
      keep.order     = TRUE,
      mb.ratio       = c(0.7, 0.3)
    )
  )
  dev.off()
}

# Build consensus peaks + UpSet plot (writes BED)
# NOTE: default overlap threshold is *2* (less stringent). Increase as needed.
consensus_peaks_function <- function(main_df, samples, condition,
                                     consensus_peak_overlap_samples = 2) {
  bool_data       <- boolean_filtering_function(main_df, samples)
  filtered_data   <- bool_data %>% mutate(across(everything(), ~ as.integer(.x)))
  filtered_data_b <- data.frame(main_df[, 1:4, drop = FALSE], filtered_data)
  filtered_data_c <- filtered_data_b %>% filter(rowSums(select(., -(1:4))) >= consensus_peak_overlap_samples)
  if (nrow(filtered_data_c) == 0) {
    message("No peaks pass the overlap threshold=", consensus_peak_overlap_samples, ". Try a smaller value.")
  }
  filtered_data_c$num_samples <- rowSums(filtered_data_c[, -(1:4), drop = FALSE])
  consensus_peaks <- data.frame(filtered_data_c[, 1:4, drop = FALSE], Height = 1, Strand = "+")
  outname <- file.path(output_wd, paste0("consensus_peaks_", condition, "_",
                                         consensus_peak_overlap_samples, "samples_", current_date, ".bed"))
  write.table(consensus_peaks, outname, col.names = FALSE, row.names = FALSE, quote = FALSE, sep = "\t")
  untreated_upsetR_plot(filtered_data_b, condition)
  filtered_data_c
}

# Overlap ladder plot (2..n)
untreated_overlap_consensus <- function(input_df, samples, condition) {
  bool_data <- boolean_filtering_function(input_df, samples) %>% mutate(across(everything(), as.integer))
  if (ncol(bool_data) < 2) {
    message("Need at least 2 samples for overlap ladder plot (", condition, ")")
    return(invisible(NULL))
  }
  upset_overlaps <- map_df(2:ncol(bool_data), function(i) {
    tibble(Overlaps = i, Peaks = nrow(bool_data %>% filter(rowSums(.) >= i)))
  })
  upset_overlap_plot <- ggplot(upset_overlaps, aes(x = Overlaps, y = Peaks)) +
    geom_bar(stat = "identity", fill = "grey") +
    geom_text(aes(label = Peaks), vjust = -0.5, color = "black", size = 5) +
    labs(title = paste0("Peaks vs. Overlaps ", condition), x = "Number of Overlaps", y = "Number of Peaks") +
    my_ggplot_theme
  plot_filename <- file.path(output_wd, paste0("upset_overlap_per_sample_", condition, "_", current_date, ".png"))
  ggsave(plot_filename, plot = upset_overlap_plot, width = 6, height = 8, dpi = 500)
}

# =============================================================================
#                             Functions from Script 02
# =============================================================================

# Recreate split files if missing (uses helper shell script in scripts/)
check_and_source_script <- function() {
  if (!file.exists(file_a) || !file.exists(file_b)) {
    script_path <- file.path(scripts_wd, "awk_consensusPeak_filtering_mergedsamples.sh")
    if (file.exists(script_path)) {
      system(paste("sh", shQuote(script_path)))
    } else {
      stop("Missing helper shell script: ", script_path)
    }
  }
}

# Donor overlap filter (>= num_overlaps TRUE)
treated_bool_func2 <- function(df, samples_cond, num_overlaps) {
  bool_subset_a <- df %>% select(1:6, all_of(samples_cond$sample))
  bool_subset_b <- bool_subset_a %>% mutate(Overlaps = rowSums(across(7:ncol(.)) == TRUE))
  bool_subset_b %>% filter(Overlaps >= num_overlaps)
}

# Swap + rename columns based on a mapping
swap_columns_and_rename <- function(df, rename_df, original_col, new_col) {
  for (i in seq_len(nrow(rename_df))) {
    original_name <- rename_df[[original_col]][i]
    new_name      <- rename_df[[new_col]][i]
    if (all(c(original_name, new_name) %in% colnames(df))) {
      temp_data           <- df[[original_name]]
      df[[original_name]] <- df[[new_name]]
      df[[new_name]]      <- temp_data
      colnames(df)[colnames(df) == original_name] <- paste0("temp_", original_name)
      colnames(df)[colnames(df) == new_name]      <- original_name
      colnames(df)[colnames(df) == paste0("temp_", original_name)] <- new_name
    } else {
      warning("Missing column(s) in swap: ", original_name, " / ", new_name)
    }
  }
  df
}

# Merge categories and list unique labels
categories_merge_function <- function(df, selection) {
  df %>%
    mutate(merged_category = paste0(Comp_C, "_", Comp_A)) %>%
    filter(Comp_D == selection) %>%
    distinct(merged_category)
}

# Grab samples from a category (optionally collapse to unique donors)
sample_select_function <- function(df, selection, single_donor = "N") {
  samples_a <- df %>% filter(Comp_D == selection)
  samples_b <- if (single_donor == "Y") samples_a else unique(samples_a$Donor)
  paste(samples_b, collapse = "|")
}

# Row means by category, merging into final_df
row_means_function <- function(categories, main_df, final_df, condition = "COND") {
  rowmean_results <- data.frame()
  for (category in categories$merged_category) {
    row_means  <- calculate_rowmean_by_category(main_df, category)
    rowmean_df <- data.frame(row_means)
    rownames(rowmean_df) <- main_df$Interval
    colnames(rowmean_df) <- category
    rowmean_results <- if (ncol(rowmean_results) == 0) rowmean_df else cbind(rowmean_results, rowmean_df)
  }
  colnames(rowmean_results) <- paste0(condition, "_", colnames(rowmean_results))
  if (ncol(final_df) == 0) rowmean_results else cbind(final_df, rowmean_results)
}

# Row means for columns matching a pattern
calculate_rowmean_by_category <- function(df, category_pattern) {
  selected_columns <- df %>% select(contains(category_pattern))
  rowMeans(selected_columns, na.rm = TRUE)
}

# =============================================================================
#                          HOMER Motif Plot Functions
# =============================================================================
# These use tab-delimited knownResults.txt and standardize column names.

.read_homer_known <- function(path = "knownResults.txt") {
  if (!file.exists(path)) stop("Missing HOMER file: ", path)
  df <- read.delim(path, header = TRUE, sep = "\t", quote = "", comment.char = "")
  names(df) <- make.names(names(df))  # e.g., "Log.P.value", "Motif.Name"
  # Strip "(...)" from motif names
  if ("Motif.Name" %in% names(df)) df$Motif.Name <- sub("\\(.*$", "", df$Motif.Name)
  df
}

create_motif_plot_c <- function(input_dir, condition, final_cond, total_rows, top_n, output_dir) {
  homer_temp_dir <- file.path(input_dir, final_cond)
  knownresult_wd <- file.path(homer_temp_dir, paste0(final_cond, "_", condition, "_accessible_homer_output"))
  if (!dir.exists(knownresult_wd)) stop("Missing HOMER dir: ", knownresult_wd)

  df <- .read_homer_known(file.path(knownresult_wd, "knownResults.txt"))
  if (!"Log.P.value" %in% names(df)) stop("HOMER file lacks 'Log.P.value' column.")

  top_data <- df %>% arrange(desc(Log.P.value)) %>% slice(1:total_rows)
  top_data$row <- seq_len(nrow(top_data))
  top_data <- top_data %>% mutate(is_top_n = if_else(row <= top_n, paste("Top", top_n), "Others"))
  top_n_data <- top_data %>% slice(1:top_n)

  motif_plot <- ggplot(top_data, aes(x = row, y = Log.P.value, color = is_top_n)) +
    geom_point(size = 1) +
    scale_color_manual(values = c(setNames("#327538", paste("Top", top_n)), "Others" = "#DDDDDD")) +
    geom_text_repel(data = top_n_data, aes(label = Motif.Name),
                    box.padding = 0.5, point.padding = 0.1, segment.color = "grey50",
                    size = 4, force = 5, nudge_x = max(top_data$row) * 0.15,
                    direction = "y", hjust = 0, segment.size = 0.2, max.overlaps = Inf) +
    my_ggplot_theme + theme(legend.position = "right") +
    labs(title = paste0(final_cond, "_", condition), x = "Rank", y = "Log10(P.value)")

  # Save a tidy copy of table we plotted
  write.table(df, file.path(homer_temp_dir, paste0(final_cond, "_", condition, "_knownResults_clean.txt")),
              row.names = FALSE, col.names = TRUE, sep = "\t", quote = FALSE)

  ggsave(file.path(output_wd, paste0("Homer_motif_plot_", final_cond, "_", condition, "_", current_date, ".png")),
         plot = motif_plot, width = 3.125, height = 4, dpi = 500)
}

create_motif_plot_v3 <- function(file_name, direction, total_rows, top_n, output_dir, color_val, custom_dir = NULL) {
  wd <- if (!is.null(custom_dir)) {
    file.path(custom_dir, paste0(direction, "_for_homer_", file_name, "_output"))
  } else {
    file.path(homer_wd, paste0(direction, "_for_homer_", file_name, "_output"))
  }
  if (!dir.exists(wd)) stop("Could not set wd: ", wd)

  df <- .read_homer_known(file.path(wd, "knownResults.txt"))
  if (!"Log.P.value" %in% names(df)) stop("HOMER file lacks 'Log.P.value' column.")

  top_data <- df %>% arrange(desc(Log.P.value)) %>% slice(1:total_rows)
  top_data$row <- seq_len(nrow(top_data))
  top_data$is_top_n <- ifelse(top_data$row <= top_n, paste("Top", top_n), "Others")
  top_n_data <- top_data[1:top_n, ]

  motif_plot <- ggplot(top_data, aes(x = row, y = Log.P.value, color = is_top_n)) +
    geom_point(size = 2) +
    scale_color_manual(name = "TFs", values = c(setNames(color_val, paste("Top", top_n)), "Others" = "#DDDDDD")) +
    geom_text_repel(data = top_n_data, aes(label = Motif.Name),
                    box.padding = 0.15, point.padding = 0.1, segment.color = "grey50",
                    size = 5, force = 10, nudge_x = max(top_data$row) * 0.15,
                    direction = "y", hjust = 0, segment.size = 0.2, max.overlaps = Inf, show.legend = FALSE) +
    my_ggplot_theme + theme(legend.position = "right") +
    labs(title = paste0(direction, " ", file_name), x = "Rank", y = "Log10(P.value)") +
    theme(plot.title = element_text(size = 10))

  ggsave(file.path(output_wd, paste0("top_", direction, "_", file_name, "_homer_motif_plot_", current_date, ".png")),
         plot = motif_plot, width = 3.125, height = 4, dpi = 500)
}

replicate_peak_overlap_function <- function(data, donor, sample_name) {
  sample_name_prefix <- paste0(donor, sample_name)
  data %>%
    select(Interval, starts_with(sample_name_prefix)) %>%
    filter(rowSums(select(., -Interval)) > 0)
}

create_motif_plot_master_list <- function(file_name, direction, total_rows, top_n, output_dir, color_val, custom_dir = NULL) {
  wd <- if (!is.null(custom_dir)) file.path(custom_dir, paste0(direction, "_for_homer_", file_name, "_output"))
  else file.path(homer_wd, paste0(direction, "_for_homer_", file_name, "_output"))
  if (!dir.exists(wd)) stop("Missing HOMER dir: ", wd)

  df <- .read_homer_known(file.path(wd, "knownResults.txt"))
  if (!"Log.P.value" %in% names(df)) stop("HOMER file lacks 'Log.P.value' column.")

  top_data <- df %>% arrange(desc(Log.P.value)) %>% slice(1:total_rows)
  top_data$row <- seq_len(nrow(top_data))
  top_data$is_top_n <- ifelse(top_data$row <= top_n, paste("Top", top_n), "Others")
  top_n_data <- top_data[1:top_n, ]

  motif_master_list_a <- top_data %>% select(Motif.Name, Consensus)

  motif_plot <- ggplot(top_data, aes(x = row, y = Log.P.value, color = is_top_n)) +
    geom_point(size = 2) +
    scale_color_manual(name = "TFs", values = c(setNames(color_val, paste("Top", top_n)), "Others" = "#DDDDDD")) +
    geom_text_repel(data = top_n_data, aes(label = Motif.Name),
                    box.padding = 0.15, point.padding = 0.1, segment.color = "grey50",
                    size = 5, force = 10, nudge_x = max(top_data$row) * 0.15,
                    direction = "y", hjust = 0, segment.size = 0.2,
                    max.overlaps = Inf, show.legend = FALSE) +
    my_ggplot_theme + theme(legend.position = "right") +
    labs(title = paste0(direction, " ", file_name), x = "Rank", y = "Log10(P.value)")

  ggsave(file.path(output_wd, paste0("top_", direction, "_", file_name, "_homer_motif_plot_", current_date, ".png")),
         plot = motif_plot, width = 3.125, height = 4, dpi = 500)

  motif_master_list_a
}

# Combined increased/decreased motif plot
create_motif_plot_both <- function(file_name, total_rows, top_n, output_dir, color_val, current_date, custom_dir = NULL) {
  processed_homer_wd <- ifelse(is.null(custom_dir), homer_wd, custom_dir)
  wd_increased <- file.path(processed_homer_wd, paste0("increased_for_homer_", file_name, "_output"))
  wd_decreased <- file.path(processed_homer_wd, paste0("decreased_for_homer_", file_name, "_output"))

  increased_file <- file.path(wd_increased, "knownResults.txt")
  decreased_file <- file.path(wd_decreased, "knownResults.txt")
  if (!dir.exists(wd_increased) || !file.exists(increased_file)) stop("Missing: ", increased_file)
  if (!dir.exists(wd_decreased) || !file.exists(decreased_file)) stop("Missing: ", decreased_file)

  read_homer_data <- function(dir_path, direction_label) {
    df <- .read_homer_known(file.path(dir_path, "knownResults.txt"))
    if (!"Log.P.value" %in% names(df)) stop("HOMER file lacks 'Log.P.value' column.")
    top_data <- df %>% arrange(desc(Log.P.value)) %>% slice(1:total_rows)
    top_data$Rank <- seq_len(nrow(top_data))
    top_data$is_top_n <- ifelse(top_data$Rank <= top_n, paste0("Top_", top_n), "Others")
    if (direction_label == "decreased") top_data$Rank <- -top_data$Rank
    top_data %>% select(Motif.Name, Log.P.value, Rank, is_top_n)
  }

  increased_data <- read_homer_data(wd_increased, "increased")
  decreased_data <- read_homer_data(wd_decreased, "decreased")

  merged_data <- bind_rows(increased_data, decreased_data) %>%
    mutate(direction = ifelse(Rank < 0, "decreased", "increased")) %>%
    mutate(plot_color = case_when(
      is_top_n == paste0("Top_", top_n) & direction == "increased" ~ color_val$increased,
      is_top_n == paste0("Top_", top_n) & direction == "decreased" ~ color_val$decreased,
      TRUE ~ "#DDDDDD"
    ))

  top_n_data <- merged_data %>% filter(is_top_n == paste0("Top_", top_n))

  motif_plot <- ggplot(merged_data, aes(x = Rank, y = Log.P.value)) +
    geom_point(aes(color = plot_color), size = 2) +
    scale_color_identity() +
    geom_text_repel(data = top_n_data, aes(label = Motif.Name, color = plot_color),
                    box.padding = 0.15, point.padding = 0.15, segment.color = "grey50",
                    size = 5, nudge_x = ifelse(top_n_data$Rank > 0, 5, -5),
                    hjust = ifelse(top_n_data$Rank > 0, -0.75, 0.75),
                    direction = "y", segment.size = 0.2, max.overlaps = Inf, show.legend = FALSE) +
    geom_vline(xintercept = 0, linetype = "dashed", color = "gray30") +
    scale_x_continuous(breaks = seq(-total_rows, total_rows, by = total_rows/2),
                       labels = abs(seq(-total_rows, total_rows, by = total_rows/2))) +
    my_ggplot_theme + theme(legend.position = "none") +
    labs(title = paste0("HOMER: ", file_name), x = "Motif Rank", y = "Log10(P-value)")

  ggsave(file.path(output_wd, paste0("HOMER_combined_", file_name, "_homer_motif_plot_", current_date, ".png")),
         plot = motif_plot, width = 4.5, height = 6, dpi = 500)
}

# =============================================================================
#                         UpSet plots for vst_counts
#   (relies on objects made by 03B_DESeq_All_Sample_Analysis.r)
# =============================================================================

function_for_upset_plot <- function(deseq_options_df, comparison_col) {
  comparison_sym <- rlang::sym(comparison_col)
  sample_map <- deseq_options_df %>% select(sample, !!comparison_sym)

  boolean_df <- vst_boolean_matrix %>%
    as.data.frame() %>%
    tibble::rownames_to_column("Interval") %>%
    pivot_longer(-Interval, names_to = "sample", values_to = "present") %>%
    left_join(sample_map, by = "sample")

  collapsed <- boolean_df %>%
    group_by(Interval, !!comparison_sym) %>%
    summarise(present = as.integer(any(present)), .groups = "drop") %>%
    filter(!is.na(!!comparison_sym))

  collapsed_matrix <- collapsed %>%
    pivot_wider(names_from = !!comparison_sym, values_from = present, values_fill = 0) %>%
    tibble::column_to_rownames("Interval")

  if (ncol(collapsed_matrix) < 2 || sum(colSums(collapsed_matrix) > 0) == 0) {
    message("Skipping UpSetR: not enough non-empty groups for ", rlang::as_string(comparison_sym))
    return(invisible(NULL))
  }

  png(file = file.path(output_wd, paste0("upsetR_shared_peaks_", current_date, "_", comparison_col, ".png")),
      width = 1800, height = 1200, res = 120)
  print(
    upset(
      as.data.frame(collapsed_matrix),
      nsets = ncol(collapsed_matrix),
      keep.order = TRUE,
      sets.bar.color = "black",
      main.bar.color = "grey",
      matrix.color = "#7E2945",
      text.scale = 1.5,
      mb.ratio = c(0.4, 0.6),
      order.by = "freq"
    )
  )
  dev.off()
}

function_for_upset_plot_by_compA <- function(comp_a_group, deseq_df = deseq_options_reps_filtered, vst_matrix = vst_boolean_matrix) {
  df_subset  <- deseq_df %>% filter(Comp_A == comp_a_group)
  sample_map <- df_subset %>% select(sample, Comp_D)

  boolean_df <- vst_matrix %>%
    as.data.frame() %>%
    tibble::rownames_to_column("Interval") %>%
    pivot_longer(-Interval, names_to = "sample", values_to = "present") %>%
    left_join(sample_map, by = "sample") %>%
    filter(!is.na(Comp_D))

  collapsed <- boolean_df %>%
    group_by(Interval, Comp_D) %>%
    summarise(present = as.integer(any(present)), .groups = "drop")

  collapsed_matrix <- collapsed %>%
    pivot_wider(names_from = Comp_D, values_from = present, values_fill = 0) %>%
    tibble::column_to_rownames("Interval")

  if (ncol(collapsed_matrix) < 2 || sum(colSums(collapsed_matrix) > 0) == 0) {
    message("Skipping ", comp_a_group, ": fewer than 2 non-empty Comp_D groups.")
    return(NULL)
  }

  png_filename <- file.path(output_wd, paste0("upsetR_peaks_", comp_a_group, "_by_CompD_", current_date, ".png"))
  message("Saving: ", png_filename)

  png(file = png_filename, width = 800, height = 600, res = 120)
  print(
    upset(
      as.data.frame(collapsed_matrix),
      nsets = ncol(collapsed_matrix),
      keep.order = TRUE,
      sets.bar.color = "black",
      main.bar.color = "grey",
      matrix.color = "#7E2945",
      text.scale = 1.25,
      mb.ratio = c(0.3, 0.7),
      order.by = "freq"
    )
  )
  dev.off()

  collapsed_matrix$overlaps <- rowSums(collapsed_matrix)
  n_shared    <- sum(collapsed_matrix$overlaps == 2)
  n_null_only <- sum(collapsed_matrix[, 1] == 1 & collapsed_matrix[, 2] == 0)
  n_rbc_only  <- sum(collapsed_matrix[, 1] == 0 & collapsed_matrix[, 2] == 1)
  total_peaks <- n_shared + n_null_only + n_rbc_only

  summary_df <- data.frame(
    RBC       = round(n_rbc_only  / total_peaks * 100, 2),
    RBCNULL   = round(n_null_only / total_peaks * 100, 2),
    Shared    = round(n_shared    / total_peaks * 100, 2),
    Total     = total_peaks,
    condition = comp_a_group
  )
  return(summary_df)
}

# =============================================================================
#                               End of Script
# =============================================================================
