#!/usr/bin/env Rscript
# =============================================================================
# 02_Count_Processing.r  (replicate-level default; robust headers + diagnostics)
# =============================================================================
# Works with:
#   FEATURE_COUNTS_FILE = consensus_peaks.mRp.clN.featureCounts.txt
#   BOOLEAN_FILE        = consensus_peaks.mLb.clN.boolean.txt  (replicate cols)
#   COLDATA_FILE        = coldata_for_DESeq2.csv
# =============================================================================

suppressPackageStartupMessages({
  library(tidyverse)
  library(readr)     # robust CSV parsing
  library(UpSetR)
})

# --------------------------- Load paths & helpers -----------------------------
scripts_wd <- file.path("/Users/brandiatteberry/Desktop/Bioinformatics/ATACseq_Analysis", "scripts")
source(file.path(scripts_wd, "00_auto_paths.R"))
if (file.exists(file.path(scripts_wd, "Function_list.r"))) {
  source(file.path(scripts_wd, "Function_list.r"))  # optional theme/helpers
}

# ------------------------ Your input file locations ---------------------------
FEATURE_COUNTS_FILE <- "/Users/brandiatteberry/Desktop/Bioinformatics/RBC_Lysis_Bioinformatics_training/consensus_peaks.mRp.clN.featureCounts.txt"
BOOLEAN_FILE        <- "/Users/brandiatteberry/Desktop/Bioinformatics/RBC_Lysis_Bioinformatics_training/consensus_peaks.mLb.clN.boolean.txt"
COLDATA_FILE        <- "/Users/brandiatteberry/Desktop/Bioinformatics/RBC_Lysis_Bioinformatics_training/coldata_for_DESeq2.csv"

# ------------------------ Fallbacks if 01 wasn't sourced ----------------------
if (!exists("current_date"))       current_date <- toupper(format(Sys.Date(), "%d%b%y"))
if (!exists("num_overlaps_ratio")) num_overlaps_ratio <- 0.8

if (!exists("filtered_counts_unsorted_file"))
  filtered_counts_unsorted_file <- paste0("all_consensus_peaks_nonsorted_with_overlap_filter_replicate_samples_", current_date, ".txt")
if (!exists("filtered_counts_file"))
  filtered_counts_file <- paste0("all_consensus_peaks_sorted_with_overlap_filter_replicate_samples_",  current_date, ".txt")

if (!exists("create_dir")) {
  create_dir <- function(p){ if(!dir.exists(p)) dir.create(p, recursive = TRUE); invisible(p) }
}

# ------------------ Split featureCounts -> scale/ helper files ----------------
file_a <- file.path(scale_wd, "consensus_peaks_first_six_columns.txt")
file_b <- file.path(scale_wd, "consensus_peaks_sorted_bam_columns.txt")

if (!file.exists(file_a) || !file.exists(file_b)) {
  if (!file.exists(FEATURE_COUNTS_FILE)) stop("Missing featureCounts file: ", FEATURE_COUNTS_FILE)
  fc_raw <- read.table(FEATURE_COUNTS_FILE, header = TRUE, comment.char = "#",
                       check.names = FALSE, sep = "\t")
  write.table(fc_raw[, 1:6],            file_a, sep = "\t", row.names = FALSE, quote = FALSE)
  write.table(fc_raw[, 7:ncol(fc_raw)], file_b, sep = "\t", row.names = FALSE, quote = FALSE)
  message("✅ Wrote split featureCounts files in scale/: ",
          basename(file_a), " & ", basename(file_b))
}

# ------------------------ Read split files and harmonize ----------------------
data_a <- read.table(file_a, header = TRUE, sep = "\t", check.names = FALSE)
# normalize header: lowercase + trim
names(data_a) <- tolower(gsub("\\s+", "", names(data_a)))
# sanity check required columns
needed <- c("geneid", "chr", "start", "end")
missing_cols <- setdiff(needed, names(data_a))
if (length(missing_cols)) {
  stop("Required columns missing in first-six file: ", paste(missing_cols, collapse=", "),
       "\nHave: ", paste(names(data_a), collapse=", "))
}

data_b <- read.table(file_b, header = TRUE, sep = "\t", check.names = FALSE)

# Clean column names to sample IDs used elsewhere (replicate-level)
trim_bam  <- function(x) sub("\\.mLb\\.clN\\.sorted\\.bam$", "", basename(x))
trim_bool <- function(x) sub("\\.mLb\\.clN\\.bool$",        "", basename(x))

colnames(data_b) <- trim_bam(colnames(data_b))
rownames(data_b) <- data_a$geneid
data_b_export    <- tibble(Interval = data_a$geneid) %>% bind_cols(as_tibble(data_b))
data_b_df        <- left_join(data_b_export, data_a, by = c("Interval" = "geneid"))

# --------------------- Read and normalize boolean table -----------------------
if (!file.exists(BOOLEAN_FILE)) stop("Boolean file not found at: ", BOOLEAN_FILE)
boolean_raw <- read.table(BOOLEAN_FILE, header = TRUE, sep = "\t",
                          check.names = FALSE, as.is = TRUE)

# Build Interval key from boolean table (robust to column casing)
nm_low <- tolower(names(boolean_raw))
grab   <- function(key) names(boolean_raw)[which(nm_low == key)][1]
if ("interval" %in% nm_low) {
  iv <- grab("interval");    boolean_raw$Interval <- as.character(boolean_raw[[iv]])
} else if ("interval_id" %in% nm_low) {
  iv <- grab("interval_id"); boolean_raw$Interval <- as.character(boolean_raw[[iv]])
} else if (all(c("chr","start","end") %in% nm_low)) {
  ch <- grab("chr"); st <- grab("start"); en <- grab("end")
  boolean_raw$Interval <- paste(boolean_raw[[ch]], boolean_raw[[st]], boolean_raw[[en]], sep=":")
} else {
  stop("Could not determine an Interval/coordinate key in the boolean file.\n",
       "Columns present: ", paste(head(names(boolean_raw), 30), collapse=", "))
}

# Keep only *.bool columns, cast to integer, and trim names
bool_cols_raw <- grep("\\.bool$", names(boolean_raw), value = TRUE)
if (length(bool_cols_raw) == 0) stop("No *.bool columns found in ", BOOLEAN_FILE)
boolean_treated <- boolean_raw %>%
  dplyr::select(Interval, dplyr::all_of(bool_cols_raw)) %>%
  dplyr::mutate(dplyr::across(-Interval, ~ as.integer(.)))
names(boolean_treated)[-1] <- trim_bool(names(boolean_treated)[-1])

# Detect replicate schema (must have _REP#)
bool_names <- names(boolean_treated)[-1]
boolean_is_replicate <- any(grepl("_REP\\d+$", bool_names))
if (!boolean_is_replicate) stop("❌ Boolean file does not look replicate-level. Use .mLb.clN.boolean.txt")
message("✔ Boolean schema detected: replicate-level (…_REP#)")

# ------------------------- Read coldata (samples/condition) -------------------
if (!file.exists(COLDATA_FILE)) stop("Coldata file not found: ", COLDATA_FILE)

# Try normal CSV first (handles most cases)
coldata <- tryCatch(
  readr::read_csv(COLDATA_FILE, show_col_types = FALSE, trim_ws = TRUE),
  error = function(e) readr::read_delim(COLDATA_FILE, delim = ",", show_col_types = FALSE, trim_ws = TRUE)
)

# If it came in as one column, split it into samples + condition
if (ncol(coldata) == 1) {
  names(coldata) <- gsub("\\s+", "", names(coldata))
  if (all(grepl(",", coldata[[1]]))) {
    coldata <- tidyr::separate(
      coldata, col = 1,
      into = c("samples", "condition"),
      sep = ",", remove = TRUE, extra = "merge", fill = "right"
    )
  } else {
    stop("Coldata appears malformed: single column without commas. Inspect file: ", COLDATA_FILE)
  }
}

# Normalize headers to expected names
names(coldata) <- gsub("\\s+", "", names(coldata))
if ("sample" %in% names(coldata)) {
  coldata <- dplyr::rename(coldata, sample_raw = sample)
} else if ("samples" %in% names(coldata)) {
  coldata <- dplyr::rename(coldata, sample_raw = samples)
} else {
  stop("Coldata must have a 'sample' or 'samples' column. Found: ", paste(names(coldata), collapse=", "))
}

if ("condition" %in% names(coldata)) {
  coldata <- dplyr::rename(coldata, condition_label = condition)
} else {
  alt <- c("Comp_A","Comp_B","Condition","group","Group")
  hit <- alt[alt %in% names(coldata)]
  if (length(hit) == 0)
    stop("Need a 'condition' column (or one of: Comp_A, Comp_B, Condition, group, Group). Found: ", paste(names(coldata), collapse=", "))
  coldata <- dplyr::rename(coldata, condition_label = !!rlang::sym(hit[1]))
}

# Trim so coldata replicate IDs match boolean replicate IDs
coldata <- coldata %>%
  dplyr::mutate(
    sample = sub("\\.mLb\\.clN\\.sorted\\.bam$", "", sample_raw),
    unit   = sample
  )

# ---------------------------- Diagnostics: matching ---------------------------
message("— DEBUG — first 6 boolean units: ", paste(head(bool_names, 6), collapse=", "))
message("— DEBUG — first 6 coldata units: ", paste(head(coldata$unit, 6), collapse=", "))

present_units      <- intersect(unique(coldata$unit), bool_names)
missing_in_bool    <- setdiff(unique(coldata$unit), bool_names)
missing_in_coldata <- setdiff(bool_names, unique(coldata$unit))

message("✔ matched boolean units: ", length(present_units))
if (length(missing_in_bool)) {
  message("⚠️ In coldata but NOT in boolean: ",
          paste(head(missing_in_bool, 20), collapse=", "),
          if (length(missing_in_bool) > 20) " ... (truncated)" else "")
}
if (length(missing_in_coldata)) {
  message("ℹ️ In boolean but NOT in coldata: ",
          paste(head(missing_in_coldata, 20), collapse=", "),
          if (length(missing_in_coldata) > 20) " ... (truncated)" else "")
}

if (length(present_units) == 0) stop("No overlap between coldata (after trimming) and boolean columns.")

# Keep only matched units downstream
coldata_filt <- coldata %>%
  dplyr::filter(unit %in% present_units) %>%
  dplyr::select(sample, unit, condition_label) %>%
  dplyr::distinct()

# Drop absent/removed units from boolean matrix
boolean_treated_filtered <- boolean_treated %>%
  dplyr::select(Interval, dplyr::all_of(unique(coldata_filt$unit)))

# ----------------------- Compute per-condition overlaps -----------------------
final_overlap_peaks <- list()
for (cond in sort(unique(coldata_filt$condition_label))) {
  cond_units <- unique(coldata_filt$unit[coldata_filt$condition_label == cond])
  if (length(cond_units) == 0) next

  mat <- boolean_treated_filtered %>% dplyr::select(Interval, dplyr::all_of(cond_units))
  thr <- ceiling(num_overlaps_ratio * length(cond_units))  # required TRUEs across units

  keep_df <- mat %>%
    dplyr::mutate(sums = rowSums(dplyr::across(-Interval))) %>%
    dplyr::filter(sums >= thr) %>%
    dplyr::select(Interval, dplyr::all_of(cond_units))

  if (nrow(keep_df) > 0) final_overlap_peaks[[cond]] <- keep_df
  message(format(Sys.time(), "%Y-%m-%d %H:%M:%S"),
          " ", cond, ": kept ", nrow(keep_df), " intervals (",
          length(cond_units), " units; thr=", thr, ").")
}

# --------------------- Build filtered replicate matrix & write -----------------
create_dir(pre_deseq_reps_wd)
setwd(pre_deseq_reps_wd)

# Always write the unsorted counts (all replicates, all intervals)
write.table(
  data_b_df,
  file = filtered_counts_unsorted_file,
  sep = "\t", quote = FALSE, row.names = FALSE
)

if (length(final_overlap_peaks) == 0) {
  message("⚠️ No conditions produced overlapping intervals; wrote only the unsorted counts:\n - ",
          file.path(pre_deseq_reps_wd, filtered_counts_unsorted_file))
} else {
  # union of all kept intervals across conditions
  iv_union <- unique(unlist(lapply(final_overlap_peaks, `[[`, "Interval")))

  # replicate counts to carry forward (only matched replicates)
  counts_cols <- intersect(names(data_b_df), coldata_filt$sample)

  consensus_peaks_filtered <- data_b_df %>%
    dplyr::filter(Interval %in% iv_union) %>%
    dplyr::select(Interval, dplyr::all_of(counts_cols), chr, start, end)

  write.table(
    consensus_peaks_filtered,
    file = filtered_counts_file,
    sep = "\t", quote = FALSE, row.names = FALSE
  )

  message(Sys.time(), " Wrote:\n - ", file.path(pre_deseq_reps_wd, filtered_counts_unsorted_file),
          "\n - ", file.path(pre_deseq_reps_wd, filtered_counts_file))

  # ----------------------------------- Plots ----------------------------------
  if (!exists("my_ggplot_theme")) {
    my_ggplot_theme <- theme_classic() +
      theme(text = element_text(color = "black"),
            plot.title = element_text(hjust = 0.5, size = rel(1.5)))
  }

  # Bar plot: intervals per condition
  df_counts <- tibble(
    condition = names(final_overlap_peaks),
    n_rows    = vapply(final_overlap_peaks, nrow, integer(1))
  )

  peaks_bar_plot <- ggplot(df_counts, aes(x = condition, y = n_rows)) +
    geom_col() +
    geom_text(aes(label = n_rows), vjust = -0.5, size = 3) +
    labs(x = "Condition", y = "Number of Overlapping Peaks",
         title = "Overlap Peak Counts per Condition") +
    my_ggplot_theme +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  ggsave(paste0("peaks_per_condition_filtered_", current_date, ".png"),
         plot = peaks_bar_plot, width = 8, height = 8, dpi = 500)

  # UpSetR (one set per condition)
  sets_list <- lapply(final_overlap_peaks, function(df) unique(df$Interval))
  png(paste0("upsetR_plot_condition_overlaps_", current_date, ".png"),
      width = 1800, height = 1000, res = 120)
  upset(
    data           = fromList(sets_list),
    order.by       = "freq",
    keep.order     = TRUE,
    main.bar.color = "grey",
    matrix.color   = "#7E2945",
    text.scale     = 1.25,
    mb.ratio       = c(0.7, 0.3)
  )
  dev.off()

  message(Sys.time(), " ✅ Finished 02_Count_Processing.r")
}
